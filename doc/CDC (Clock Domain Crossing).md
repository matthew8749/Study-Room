# CDC (Clock Domain Crossing).md
重要的設計考慮因素要求在跨時鐘域（CDC）邊界處仔細構建多時鐘設計。本文詳細介紹了一些最新的策略和最著名的方法，以解決一個和多個信號跨越CDC邊界的問題。論文中包括與CDC驗證相關的技術，以及用於在時鐘域之間傳遞多個控制信號的有趣的2深度FIFO設計。儘管本文中描述的設計方法通常可以使用任何HDL來實現，但示例是使用有效的SystemVerilog技術來展示的。

## 2.0 亞穩態
亞穩態是指在設計的正常操作期間的某個時刻，在某個持續時間內不呈現穩定的0或1狀態的信號。在多時鐘設計中，亞穩態是無法避免的，但亞穩態的有害影響可以被抵消。
![image](https://github.com/matthew8749/Study-Room/blob/main/img_src/Sunburst%20CDC%202008/Figure%202%20-%20Metastable%20bdat1%20output%20propagating%20invalid%20data%20throughout%20the%20design.png)(圖1-異步時鐘和同步失敗)  
    引用Dally和Poulton關於轉移性的書[9]：“當用時鐘對不斷變化的數據信號進行採樣時……事件的順序決定了結果。事件之間的時間差越小，確定哪個先發生的時間就越長。當兩個事件發生得非常接近時，決策過程可能需要比分配的時間更長的時間，並且會發生同步失敗。"
    圖1顯示了當在一個時鐘域中生成的信號被採樣到離第二個時鐘區域的時鐘信號的上升沿太近時發生的同步失敗。同步失敗是由於輸出變得亞穩，並且在必須再次採樣時沒有收斂到合法的穩定狀態。

### **2.1 為什麼亞穩態是一個問題？**
那麼，為什麼亞穩態是個問題呢？圖2顯示，通過接收時鐘域中的附加邏輯的亞穩態輸出可能導致非法信號值在整個設計的其餘部分傳播。由於CDC信號可以波動一段時間，所以接收時鐘域中的輸入邏輯可以將波動信號的邏輯電平識別為不同的值，並因此將錯誤信號傳播到接收時鐘區域中。


PIC




在任何設計中使用的每個觸發器都有指定的setup和hold時間，或者在上升時鐘沿前後不允許數據輸入改變的時間。這個時間窗口被指定為設計參數，精確地防止數據信號與另一個同步信號變化得太近，從而可能導致輸出變為亞穩態。
## 3.0 同步器

在時鐘域之間傳遞信號時，需要問的一個重要問題是，我是否需要對從一個時鐘域傳遞到另一個時鐘域的信號的每個值進行採樣？

### 3.1兩種同步場景

在跨越CDC邊界傳遞信號時，有兩種情況是可能的，確定哪種情況適用於您的設計很重要：
（1） 允許錯過在時鐘域之間傳遞的樣本。
（2） 必須對在時鐘域之間傳遞的每個信號進行採樣。
第一種情況：有時不需要對每個值進行採樣，但採樣值的準確性很重要。一個例子是在標準異步FIFO設計中使用的一組格雷碼計數器。在設計合理的異步FIFO模型中，同步格雷碼計數器不需要從相反的時鐘域捕獲每個合法值，但至關重要的是，採樣值要準確，以識別何時出現滿和空情況。
第二種情況：在允許更改CDC信號之前，必須正確識別或識別並確認CDC信號。在這兩種情況下，CDC信號將需要某種形式的同步到接收時鐘域。

### 3.2 Two flip-flop synchronizer（兩個觸發器同步）

再次引用Dally和Poulton[9]關於同步器的內容：“同步器是一種對異步信號進行採樣並輸出轉換與本地時鐘或採樣時鐘同步的信號版本的設備。”
數字設計師使用的最簡單、最常見的同步器是兩級觸發器同步器，如圖3所示。
第一觸發器將異步輸入信號採樣到新的時鐘域中，並等待一個完整的時鐘週期以允許第一級輸出信號上的任何亞穩性衰減，然後通過相同的時鐘將第一級信號採樣到第二級觸發器中，其預期目標是階段2信號現在是一個穩定有效的信號，同步並準備在新的時鐘域內分發。

![                                                                                 圖3 - 兩級同步觸發器](attachment:bde76ed9-a7ec-429b-b66e-d4abf0abfaa8:4600bdf675c2b761d445a43bcd4a3950.png)

                                                                                 圖3 - 兩級同步觸發器

    理論上，當信號被計時到第二級以使第二級輸出信號也變為亞穩時，第一級信號仍然足夠亞穩是可能的。同步故障間隔時間（MTBF）概率的計算是多個變量的函數，包括用於生成輸入信號和為同步觸發器計時的時鐘頻率。在Dally和Poulton[9]中可以找到對MTBF計算的一種描述。對於大多數同步應用，雙觸發器同步器足以消除所有可能的亞穩態。

### 3.3 MTBF-故障前平均時間

對於大多數應用，對任何跨越CDC邊界的信號進行平均故障前時間（MTBF）計算是很重要的。從這個意義上說，故障意味著一個信號被傳遞到同步觸發器，在第一級同步器觸發器上變為亞穩態，並且在一個週期後當它被採樣到第二級同步器觸發時繼續是亞穩態。由於信號在一個時鐘週期後沒有穩定到已知值，因此當採樣並傳遞到接收時鐘域時，信號仍然可以是亞穩的，從而導致相應邏輯的潛在故障。
在計算MTBF數時，較大的MTBF數表示潛在故障之間的時間間隔較長，而較小的MTBF數則表示亞穩態可能頻繁發生，類似地會導致設計中的故障。
Dally和Poulton[9]給出了一個很好的方程，對可以用來計算同步器電路MTBF的計算進行了非常徹底的分析。在不重復等式和分析的情況下，應該指出的是，直接影響同步器電路MTBF的兩個最重要的因素是，採樣時鐘頻率（信號被採樣到接收時鐘域的速度有多快）和數據變化頻率（CDC邊界的數據變化速度有多快）。

![                                                                     圖4-造成MTBF短值的主要因素](attachment:b657638c-98eb-4b03-b82c-0c9415e7f11a:da37734540b1888f697f1c8da13930da.png)

                                                                     圖4-造成MTBF短值的主要因素

     從上面的部分方程可以看出，在高速設計中，或者當採樣數據變化更頻繁時，故障發生的頻率更高（MTBF更短）。

### **3.4 Three flip-flop synchronizer（三級觸發器同步器）**

對於一些非常高速的設計，雙觸發器同步器的MTBF太短，增加第三個觸發器以將MTBF增加到令人滿意的持續時間。當然，是由設計的架構師決定的。

![                                                                   圖5-用於高速設計的三觸發器同步器](attachment:14138c72-db6a-42c9-8b38-6a60ca1c69d4:e546f1bb0432de808642462a815c1595.png)

                                                                   圖5-用於高速設計的三觸發器同步器

### **3.5 Synchronizing signals from the sending clock domain（同步來自發送時鐘域的信號）**

關於CDC設計的常見問題：在將信號傳遞到接收時鐘域之前，寄存來自發送時鐘域的信號是個好主意嗎？問題中隱含的是CDC信號將被同步到接收時鐘域的假設；因此，它們不需要在發送時鐘域中進行同步。這種合理化是不正確的，通常需要在發送時鐘域中寄存信號。
考慮一個示例，其中發送時鐘域中的信號在傳遞到接收時鐘域之前沒有寄存，如圖6所示。

![48e8a7324e42369dd5f4782c5d15b890.png](attachment:06f57c27-f240-43f0-bc38-9832810c466d:48e8a7324e42369dd5f4782c5d15b890.png)

                                                    圖6-跨越CDC邊界發送的未寄存信號
    在這個例子中，來自發送時鐘域的組合輸出可能在CDC邊界處經歷組合邏輯毛刺。這種組合沈降有效地增加了數據變化頻率，可能會產生振蕩數據的小突發，從而增加了在變化時可以採樣的邊沿數量，相應地增加了採樣變化數據和生成亞穩信號的可能性。

### **3.6 Synchronizing signals into the receiving clock domain（將信號同步到接收時鐘域）**

發送時鐘域中的信號在被傳遞到CDC邊界之前應該被同步。來自發送時鐘域的信號同步減少了可以在接收時鐘域中採樣的邊沿數量，有效地降低了MTBF方程中的數據變化頻率，從而增加了計算故障之間的時間（有關數據變化頻率對MTBF的影響的描述，請參閱第3.3節）。

![4f78063639f26645c8e090db757d509e.png](attachment:117921bc-ea81-4de0-9b53-e9517af804f2:4f78063639f26645c8e090db757d509e.png)

                                             圖7-CDC邊界發送的寄存信號
     在圖7中，aclk邏輯在被傳遞到bclk域之前，在adat觸發器上進行設置。adat觸發器過濾掉觸發器輸入（a）上的組合邏輯毛刺，並將乾淨信號傳遞給bclk邏輯。

---

## **4.0 Synchronizing fast signals into slow clock domains（將快速信號同步到慢速時鐘域）**

如第3.1節所述，如果CDC信號在時鐘域之間傳遞時不能跳過，那麼當信號在時鐘域之間傳遞的時候，考慮信號寬度或同步技術是很重要的。與同步器相關的一個問題是，來自發送時鐘域的信號可能在被採樣之前改變兩次值，或者可能過於接近較慢時鐘域中的採樣邊沿。在信號從一個時鐘域發送到另一個時鐘域的任何時候都必須考慮這種可能性，並且必須確定遺漏的信號是否是所討論的設計的問題。
當不允許遺漏樣本時，有兩種解決問題的通用方法：

（1） 一種開環解決方案，可確保在沒有確認的情況下捕獲信號。

（2） 一種閉環解決方案，需要確認接收到跨越CDC邊界的信號。

本節將討論這兩種解決方案。

### **4.1 Requirement for reliable signal passing between clock domains（時鐘域之間可靠信號通過的要求）**

如果較快時鐘域是較慢時鐘域的頻率（或更高）的1.5倍，則將較慢的控制信號同步到較快的時鐘域通常不是問題，因為較快的時鐘信號將對較慢的CDC信號採樣一次或多次。認識到將較慢信號採樣到較快時鐘域比將較快信號採樣到較慢時鐘域引起的潛在問題更少，設計者可以利用這一事實，使用簡單的雙觸發器同步器在時鐘域之間傳遞單個CDC信號。

**4.1.1 The "three edge" requirement（三邊沿要求）**

Mark Litterick[4]指出，當通過雙觸發器同步器在時鐘域之間傳遞一個CDC信號時，CDC信號必須比接收域時鐘週期的週期寬度的1-1/2倍寬。Littereick將這一要求描述為“輸入數據值必須在三個目標時鐘邊沿保持穩定。”對於超長的源和目的時鐘頻率，這一要求可能會安全地放寬到接收時鐘域週期時間的1-1/4倍或更短，但“三邊沿”准則是最安全的初始設計條件，並且通過使用SystemVerilog斷言比在模擬期間動態測量CDC信號的分數寬度更容易證明。“三邊沿”要求實際上適用於開環和閉環解決方案，但閉環解決方案的實現會自動確保所有CDC信號至少檢測到三個邊沿。

### **4.2 Problem - passing a fast CDC pulse（通過快速CDC脈衝）**

考慮嚴重缺陷的情況，其中發送時鐘域的頻率高於接收時鐘域，並且CDC脈衝在發送時鐘區域中只有一個週期寬。如果CDC信號僅一個快速時鐘週期脈衝，則CDC信號可能在較慢時鐘的上升沿之間變高和變低，並且不會被捕獲到較慢時鐘域中，如圖8所示。

![fc5dd3580f8eb0b913a6deab7ce5e5ff.png](attachment:5915dc21-328c-44dd-ad7a-f8fd123a26d7:fc5dd3580f8eb0b913a6deab7ce5e5ff.png)

                                                圖8-同步期間遺漏的短CDC信號脈衝

### **4.3 Problem - sampling a long CDC pulse - but not long enough!（問題-採樣一個長的CDC脈衝-但不夠長）**

考慮發送時鐘域向接收時鐘域發送比接收時鐘頻率的週期稍寬的脈衝的有點不直觀和有缺陷的情況。在大多數情況下信號將被採樣並通過，但是存在CDC脈衝將在太靠近接收時鐘域的兩個上升時鐘邊沿處改變的微小但真實的可能性，並且從而違反第一時鐘邊沿上的建立時間並且違反第二時鐘邊沿的保持時間並且不形成預期脈衝。這種可能的故障如圖9所示。

![5de9b3972e221b537b393cf14db2ddfe.png](attachment:e13b5488-7a71-4df0-b3d0-240df3a5955b:5de9b3972e221b537b393cf14db2ddfe.png)

                                圖9-違反目的地setup和hold時間的邊際CDC脈衝

### **4.4 Open-loop solution - sampling signals with synchronizers(開環解決方案-使用同步器對信號進行採樣)**

這個問題的一個潛在解決方案是在超過採樣時鐘週期時間的一段時間內斷言CDC信號，如圖10所示。如第4.1.1節所述，最小脈衝寬度是接收時鐘頻率週期的1.5倍。假設CDC信號將被接收器時鐘至少採樣一次，並且可能採樣兩次。
當相對時鐘頻率固定並正確分析時，可以使用開環採樣。
優點：開環解決方案是通過CDC邊界傳遞信號的最快方式，無需確認接收到的信號。
缺點：與開環解決方案相關的最大潛在問題是，另一位工程師可能會將該解決方案誤認為是通用解決方案，或者設計要求可能會發生變化，而工程師可能無法重新分析原始的開環解決方案。
通過在模型中添加SystemVerilog斷言來檢測輸入脈衝是否未能超過“三邊沿”設計要求，可以將此問題降至最低。

![24c8494924a9f5ee2a6bfb8e1318a21f.png](attachment:41dafa62-1cdf-46f0-b144-958950135386:24c8494924a9f5ee2a6bfb8e1318a21f.png)

                                    圖10-延長脈衝以保證對控制信號進行採樣

### **4.5 Closed loop solution - sampling signals with synchronizers（閉環解決方案-帶同步器的採樣信號）**

這個問題的第二個潛在解決方案是發送使能控制信號，將其同步到新的時鐘域中，然後將同步信號通過另一個同步器返回到發送時鐘域作為確認信號。
優點：同步反饋信號是一種非常安全的技術，可以確認第一個控制信號已被識別並採樣到新的時鐘域中。
缺點：在允許控制信號改變之前，在兩個方向上同步控制信號可能會有相當大的延遲。

![f37dde8d40f35313946162189f84d6e4.png](attachment:217ab060-bfaf-47bc-a3d4-3424a91d4ab8:f37dde8d40f35313946162189f84d6e4.png)

                                            圖11-帶有反饋的信號以確認接收

---

在時鐘域之間傳遞多個信號時，簡單的同步器無法保證數據的安全傳遞。工程師在進行多時鐘設計時經常犯的一個錯誤是將同一事務中所需的多個CDC位從一個時鐘域傳遞到另一個時鐘域，並忽略了CDC位同步採樣的重要性。
問題在於，與一個時鐘同步的多個信號將經歷小的數據變化偏斜，該偏斜偶爾可以在第二時鐘域中的不同上升時鐘沿上採樣。
即使我們能夠完美地控制和匹配多個信號的布線長度，上升和下降時間的差異以及整個die的工藝變化也可能會引入足夠的偏斜，從而導致在其他精心匹配的布線上出現採樣失敗。必須採用多位CDC策略來避免多位值的偏斜採樣。

## **5.0 Passing multiple signals between clock domains（在時鐘域之間傳遞多個信號）**

### **5.1 Multi-bit CDC strategies（多 bit CDC策略）**

為了避免多位CDC偏斜的採樣場景，我將多位CDC策略分為三大類：

（1） 多位信號合併。
在可能的情況下，將多個CDC位合併為1位CDC信號。
（2） 多週期路徑方案。
使用同步加載信號安全地通過多個CDC位。
（3） 使用格雷碼傳遞多個CDC比特。

這些策略中的每一個都將在本節的剩餘部分中詳細介紹。

### **5.2 Multi-bit signal consolidation（多 bit 信號合併）**

在可能的情況下，將多個CDC信號合併為1位CDC信號。問自己一個問題，我真的需要多個比特來控制跨越CDC邊界的邏輯嗎？
簡單地在所有CDC位上使用同步器並不總是足夠好，如以下示例所示。如果控制信號的順序或對齊是重要的，則必須注意將信號正確地傳遞到新的時鐘域中。本節中顯示的所有示例都過於簡單，但它們非常模仿真實設計中經常出現的情況。

### 5.3 Problem - Two simultaneously required control signals（同時需要兩個控制信號）

在圖12所示的簡單示例中，接收時鐘域中的寄存器需要load信號和enable信號才能將數據值加載到寄存器中。如果load信號和enable信號都在同一髮送時鐘沿上被驅動，則控制信號之間的小偏斜可能導致兩個信號被同步到接收時鐘域內的不同時鐘週期中。在這些條件下，數據將不會加載到寄存器中。

![478436fa43a68fde43c6f1b804038f41.png](attachment:602e7dfc-3b2a-46d7-af98-dde2389a410c:478436fa43a68fde43c6f1b804038f41.png)

                                    圖12-問題-在時鐘域之間傳遞多個控制信號

### **5.3.1 Solution - Consolidation（解決方案-整合）**

第5.3節中問題的解決方案很簡單，即合併控制信號。如圖13所示，僅從一個 load-enable信號驅動接收時鐘域中的load 和 enable寄存器輸入信號。合併將消除兩個控制信號在時間上偏移到達的可能性。

![246671e8a9da544724da6e78fa4a0ce4.png](attachment:8a3fa877-9e80-4d88-9d3e-e307c202b25f:a32555fe-a4db-4ddc-a046-a006b7573c86.png)

                             圖13-解決方案-在時鐘域之間傳輸之前合併控制信號

### **5.4 Problem - Two phase-shifted sequencing control signals（兩個相移序列控制信號）**

圖14中的圖表顯示了兩個使能信號b_ld1和b_ld2，它們從發送時鐘域依次驅動到接收時鐘域，以控制流水線數據寄存器的使能輸入。問題在於，在第一時鐘域中，b_ld1控制信號可能在b_ld2控制信號生成之前稍微終止，並且接收時鐘的上升沿可能出現在b_ld1和b_ld2控制脈衝之間的微小間隙中，導致在接收時鐘域的使能控制信號鏈中形成一個週期的間隙。這將導致a2數據值被第二寄存器遺漏。

![363fdce7b6a6102825f343311b065998.png](attachment:3e94f6d4-6a17-4665-9212-42e662b23a0e:363fdce7b6a6102825f343311b065998.png)

                                    圖14-問題-在時鐘域之間傳遞順序控制信號

### 5.4.1 Solution - consolidation and an extra flip-flop（整合和一個額外的觸發器）

如圖15所示，這個問題的解決方案是只向接收時鐘域發送一個控制信號，並在接收時鐘區域內生成第二個相移流水線使能信號。

![d17b977d8dfba7d5c27097c27ed0ba34.png](attachment:99527595-8a8b-46fd-a41f-8f991741d3a6:d17b977d8dfba7d5c27097c27ed0ba34.png)

                     圖15-解決方案-在新時鐘域中生成正確序列信號的邏輯

### **5.5 Problem - Multiple CDC signals（多個CDC信號）**

圖16中的圖表顯示了兩個編碼的控制信號在時鐘域之間傳遞。如果兩個編碼信號在採樣時略微偏斜，則在接收時鐘域中的一個時鐘週期內可能產生錯誤的解碼輸出。

![螢幕擷取畫面 2025-03-27 084940.png](attachment:eb5e9891-2bf4-411b-bfce-b417d0439358:螢幕擷取畫面_2025-03-27_084940.png)

                                    圖16-問題-時鐘域之間傳遞的編碼控制信號

### **5.5.1 Solutions for passing multiple CDC signals （通過多個CDC信號的解決方案）**

多週期路徑（MCP）方案和FIFO技術可用於解決與傳遞多個CDC信號有關的問題。
MCP方案的描述和定義見第5.6節，至少有兩種多週期路徑（MCP）方案可用於解決此問題：
（1） 閉環-MCP方案，帶反饋。
（2） 閉環-MCP方案，帶有確認反饋。
MCP方案的實現技術將在下一節開始介紹。
還有至少兩種FIFO策略可以作為這個問題的閉環解決方案：
（1） 異步FIFO實現。
（2） 2-deep  FIFO實現。
FIFO實現技術從第5.8節開始描述。

![62452b2e02ba5a2c71d039584c7e795f.png](attachment:d6e5d920-bc9b-461e-bfab-34a7287c7ca0:62452b2e02ba5a2c71d039584c7e795f.png)

                                    圖17-在時鐘域之間傳遞同步使能脈衝的邏輯

使用MCP方案是用於安全地傳遞多個CDC信號的常用技術。MCP方案是指將未同步的數據發送到與同步的控制信號配對的接收時鐘域。同時發送數據和控制信號，允許數據建立在目的寄存器的輸入上，同時在控制信號到達目的寄存器的加載輸入之前同步兩個接收時鐘週期。
優勢：
（1） 發送時鐘域不需要計算在時鐘域之間發送的適當脈衝寬度。
（2） 發送時鐘域只需要將使能切換到接收時鐘域，以指示數據已經通過並準備好加載。
使能信號不需要返回到其初始邏輯電平。該策略在沒有同步的情況下傳遞多個CDC信號，並同時將同步的使能信號傳遞到接收時鐘域。在同步使能通過同步並到達接收寄存器之前，不允許接收時鐘域對多位CDC信號進行採樣。
這種策略被稱為多週期路徑方案[8]，因為未同步的數據字被直接傳遞到接收時鐘域，並保持多個接收時鐘週期，從而允許在未同步數據字改變之前將使能信號同步並識別到接收時鐘域。因為未同步的數據在被採樣之前被傳遞並保持穩定多個時鐘週期，所以採樣值不會變得亞穩。

### **5.6 Multi-Cycle Path (MCP) formulation（多週期路徑（MCP）方案）**

### **5.6.1 MCP formulation using a synchronized enable pulse（使用同步使能脈衝的MCP方案）**

在時鐘域之間傳遞同步使能信號的最常見方法可能是使用傳遞到同步脈衝發生器的翻轉使能信號，以指示可以在下一個接收時鐘邊沿捕獲未同步的多週期數據字，如圖18所示。
這種同步使能脈衝產生的一個關鍵特徵是輸入信號的極性無關緊要。在圖18中，d輸入在週期1中被切換為高電平，到週期4時，高信號已經通過三個同步觸發器傳播。在週期3中，q2和q3觸發器的輸出具有不同的極性，使得同步使能脈衝在同一週期中在異或門的輸出上形成。類似地，d輸入在週期7中被切換為低，並且到週期10，高信號已經通過三個同步觸發器傳播。再次在週期9中，q2和q3觸發器的輸出具有不同的極性，導致同步使能脈衝在異或門的輸出上形成。

![5b063e0995af964774f46c0b8ec662d2.png](attachment:0f5b5a5d-c76c-45c7-bded-f9e4d8f6ea36:5b063e0995af964774f46c0b8ec662d2.png)

                                                                              圖18-同步脈衝生成邏輯
    由於第5.0節中描述的所有MCP方案都使用同步使能脈衝生成電路，因此創建並使用較小的等效符號來表示同步使能脈衝生成電路被認為是有用的。等效符號如圖19所示。

![c433df4bcb083c8aa47f6c3fbebf6d2d.png](attachment:60a2b276-8970-4d24-923d-8841678f8ace:c433df4bcb083c8aa47f6c3fbebf6d2d.png)

                                     圖19-同步使能脈衝生成邏輯和等效符號
    除了生成任何d輸入極性的脈衝關斷之外，同步使能脈衝生成電路還具有跟隨延遲了三個時鐘週期的d輸入的q輸出。q輸出經常被用作反饋信號，並且作為確認信號通過發送時鐘域中的另一個同步使能脈衝生成電路。圖20顯示了典型的發送-接收觸發脈衝生成設計。

![d90cd29d07865e8533fa9637167a916e.png](attachment:68a60971-c08c-4600-a55d-69e4a0f54177:d90cd29d07865e8533fa9637167a916e.png)

                                                       圖20-多循環路徑（MCP）方案觸發脈衝生成
    使用這種技術，需要接收時鐘域具有適當的邏輯以在檢測到脈衝時捕獲數據，因為脈衝對於每個多週期數據字僅一個接收時鐘週期有效。

### **5.6.2 Closed-loop - MCP formulation with feedback（閉環-帶反饋的MCP方案）**

使用MCP方案時的一個重要技術是將使能信號作為確認信號傳遞回發送時鐘域，如圖21所示。

![2942049409b33e5896aecf8ab7cc7ca8.png](attachment:73b6843e-d3cc-4241-b6e2-fd764ac17c33:2942049409b33e5896aecf8ab7cc7ca8.png)

                             圖21-多循環路徑（MCP）方案觸發脈衝生成和確認
    對於圖21中的示例，確認反饋信號（b_ack）生成一個確認脈衝（aack），該脈衝用作小型READY-BUSY、1-狀態FSM塊的輸入，該塊生成一個就緒信號（aready），以指示現在可以安全地再次更改數據輸入（adatain）值。一旦aready信號變高，發送器就可以自由發送新數據（adatain）和伴隨的asend控制信號。這是一個自動反饋路徑，它假設接收時鐘域將始終為通過MCP方案同步的下一個數據字做好準備。

### **5.6.3 Closed-loop - MCP formulation with acknowledge feedback（閉環-具有確認反饋的MCP方案）**

第5.6.2節中描述的技術的一個完全響應的變體使用MCP方案，即只有在接收時鐘域用bload脈衝確認接收到數據後，才將使能信號作為確認信號傳遞回發送時鐘域，如圖22所示。

![0fd57f2e34bd9beac6fc6447262b69a7.png](attachment:d40d861a-619f-49fc-becb-0cc13659bdac:0fd57f2e34bd9beac6fc6447262b69a7.png)

                                  圖22-多循環路徑（MCP）方案翻轉脈衝生成（帶就緒確認）

對於圖22中的示例，接收時鐘域有一個小的WAIT-READY，1-狀態FSM，當數據寄存器輸入上的數據有效時，它會向接收邏輯發送有效信號（bvalid）。直到接收邏輯確認應該通過斷言bload信號來加載數據，才實際加載數據。在數據被加載之前，沒有對發送時鐘域的反饋，然後b_ack信號被發送回與具有自動反饋的MCP方案相同的信號。這是一條反饋路徑，在捕獲數據和發送反饋之前，需要對接收時鐘域的一部分進行操作。

### 5.7 Synchronizing counters（同步計數器）

如前所述，當在時鐘域之間傳遞多個信號時，需要問的一個重要問題是，我是否需要對從一個時鐘域傳遞到另一個時鐘域的信號的每個值進行採樣？對於計數器，答案經常是否定的！
參考文獻[1]詳細介紹了FIFO設計技術，其中在時鐘域之間對格雷碼計數器進行採樣，並且經常遺漏中間格雷計數值。對於這種FIFO設計，更需要考慮的是確保計數器不會超出其邊界，這可能會導致丟失滿和空標誌檢測。即使時鐘域之間的採樣格雷計數值經常被遺漏，該設計也是穩健的，並且所有重要的格雷計數值都被適當地採樣。有關詳細信息，請參見[1]。
由於有效的設計可能被允許跳過一些計數值樣本，那麼任何計數器都可以用來跨越CDC邊界傳遞計數值嗎？答案是否定的。

### 5.7.1 Binary counters（二進制計數器）

二進制計數器的一個特徵是，所有順序二進制遞增操作的一半要求兩個或多個計數器位必須改變。試圖在CDC邊界上同步二進制計數器與試圖將多個CDC信號同步到新的時鐘域中是一樣的。如果一個簡單的4位二進制計數器從地址7（二進制0111）變為地址8（二進制1000），則所有四個計數器位將同時改變。如果同步時鐘邊沿位於該轉換的中間，則可以對任何4位二進制模式進行採樣，並將其同步到新的時鐘域中，如圖23所示。

![image.png](attachment:9141bdfb-db59-47bb-a5a0-0ca5aa31d6b5:image.png)

                                                                 圖23-轉換中期採樣的二進制計數值

在FIFO設計中，新的同步二進制值（也就是目標時鐘域採集到的數據）可能會觸發假滿或空標誌，或者更糟的是，它可能不會觸發真正的滿或空標記，從而導致數據因FIFO溢出而丟失，或者在FIFO真正為空時，由於試圖讀取數據而導致從FIFO讀取無效數據。

5.7.2格雷碼（格雷碼）
格雷碼以Frank Gray[4]命名，可用於多時鐘設計的最安全計數器是格雷碼計數器。格雷碼只允許每個時鐘轉換改變一個比特，從而消除了試圖在時鐘域上同步多個變化的CDC比特的相關問題。標準格雷碼具有非常好的轉換特性，可以將格雷碼轉換為二進制，然後再轉換回來。使用這些轉換，可以簡單地設計高效的格雷碼計數器。
5.7.3 Gray-to-binary conversion（格雷碼轉換為二進制碼）
為了將格雷碼值轉換為等效的二進制碼值，以n位格雷碼值為例，二進制位0等於與從1到n的所有其他格雷碼位獨佔的格雷碼位0的異或。二進制比特1等於格雷碼比特1，與從2到n的所有其他格雷碼比特異或，等等。最高有效二進制位恰好等於最高有效格雷碼位。樣本4位格雷碼到二進制轉換的方程式如圖24所示。

![                                                                                      圖24-4位灰度到二進制的轉換方程](attachment:a9fa8b3a-aec3-40b7-9562-f362813cd4bf:image.png)

                                                                                      圖24-4位灰度到二進制的轉換方程

    對格雷碼到二進制轉換器進行編碼的最簡單方法是對for循環進行編碼，並對具有可變索引範圍的格雷碼向量進行異或歸約，其中每次通過循環，索引範圍的LSB都會增加，直到我們只剩下bin[MSB]=^gray[MSB:MSB]（僅格雷碼向量的1位MSB）的簡單賦值，如示例1所示。

```verilog
module gray2bin_bad #(parameter SIZE = 4)
  (output logic [SIZE-1:0] bin,
   input logic [SIZE-1:0] gray);
   // Syntax Error - variable index range
   always_comb
     for (int i=0; i<SIZE; i++)
       bin[i] = ^(gray[SIZE-1:i]);
endmodule

```

    不幸的是，Verilog和SystemVerilog不允許使用可變索引範圍進行部件選擇，因此示例1中的代碼雖然在概念上是正確的，但不會編譯。
    要解決這個問題，請記住，異或門實際上是一個可編程反相器。如果一個輸入為高電平，則另一個輸入被反相並傳遞到輸出。類似地，如果一個輸入被綁定為低，則另一個輸入在沒有反轉的情況下被傳遞到輸出（從輸入到輸出沒有變化）。利用這樣一個事實，即任何添加的異或或涉及0輸入的操作都不會改變操作的結果，格雷碼到二進制轉換的方法是使用填充的0來異或或有效的格雷碼位，如圖25所示。

```verilog
bin[0] = gray[3] ^ gray[2] ^ gray[1] ^ gray[0] ; // gray>>0
bin[1] = 1'b0    ^ gray[3] ^ gray[2] ^ gray[1] ; // gray>>1
bin[2] = 1'b0    ^ 1'b0    ^ gray[3] ^ gray[2] ; // gray>>2
bin[3] = 1'b0    ^ 1'b0    ^ 1'b0    ^ gray[3] ; // gray>>3
```

    該簡化算法的相應參數化SystemVerilog模型如示例2中所示。這個例子在語法上是正確的，可以編譯並且確實有效。

```verilog
module gray2bin #(parameter SIZE = 4)
(output logic [SIZE-1:0] bin,
input logic [SIZE-1:0] gray);
always_comb
for (int i=0; i<SIZE; i++)
bin[i] = ^(gray>>i);
endmodule
```

                                              示例2-參數化和正確的格雷碼到二進制SystemVerilog模型
    輸入綁定到0的所有額外的異或操作會發生什麼？綜合工具認識到，可以優化一個輸入上具有常數0的異或門，以推斷出設計的非常有效的實現。

### 5.7.4 Binary-to-gray conversion（二進制到格雷碼的轉換）

為了將二進制值轉換為等效格雷碼值，以n位二進制值為例，格雷碼位0等於二進制位0和1的異或。格雷碼比特1等於二進制比特1和2的異或，等等。最高有效格雷碼位恰好等於最高有效二進制位。樣本4位二進制到格雷碼轉換的方程式如圖26所示。

```verilog
gray[0] = bin[0] ^ bin[1];
gray[1] = bin[1] ^ bin[2];
gray[2] = bin[2] ^ bin[3];
gray[3] = bin[3] ^ 1'b0 ; // same as gray[3] = bin[3];
```

    對二進制到格雷碼轉換器進行編碼的最簡單方法是對簡單的連續賦值進行編碼，該賦值在二進制矢量和同一二進制矢量的右移版本之間執行逐位異或運算，如示例3所示。這個例子在語法上是正確的，可以編譯並且確實有效。

```verilog
module bin2gray #(parameter SIZE = 4)
(output logic [SIZE-1:0] gray,
input logic [SIZE-1:0] bin);
assign gray = (bin>>1) ^ bin;
endmodule
```

5.7.5 Gray code counter style #1（格雷碼計數器類型#1）

我們可以使用第5.7.3節和第5.7.4節中所示的轉換來構建格雷碼計數器。對於任何格雷碼計數器，重要的是要記住，必須註冊灰度輸出，以消除設計中的任何組合沈降。用於格雷碼計數器樣式#1的SystemVerilog代碼包含一個灰度到二進制轉換器、一個二進制到灰度轉換器，並在轉換之間增加二進制值，如圖27所示。

![                                                                             圖27-1型格雷碼計數器-只有一個格雷碼寄存器](attachment:86923074-3a5d-4cb9-b21a-cc822ba57b12:448e6e1baf495ea82b604d5d946ec459.png)

                                                                             圖27-1型格雷碼計數器-只有一個格雷碼寄存器

示例4中示出了用於格雷碼計數器樣式#1的相應參數化SystemVerilog模型。

```verilog
module graycntr #(parameter SIZE = 5)
(output logic [SIZE-1:0] gray,
input logic clk, inc, rst_n);
logic [SIZE-1:0] gnext, bnext, bin;
always_ff @(posedge clk or negedge rst_n)
if (!rst_n) gray <= '0;
else gray <= gnext;
always_comb begin
for (int i=0; i<SIZE; i++)
bin[i] = ^(gray>>i);
bnext = bin + inc;
gnext = (bnext>>1) ^ bnext;
end
endmodule
```

### 5.7.6 Gray code counter style #2（格雷碼計數器類型#2）

我們可以通過使用第5.7.4節中所示的二進制到格雷碼的轉換來構建第二種類型的格雷碼計數器。這個格雷碼計數器實際上既是二進制計數寄存器又是格雷碼計數寄存器。

![                                                              圖28-格雷碼計數器類型#2-二進制寄存器和格雷碼寄存器](attachment:9cb8c615-71f2-4ae2-9b87-e5196a2ab748:12c06d481162e3cbf2d613c24a2d294c.png)

                                                              圖28-格雷碼計數器類型#2-二進制寄存器和格雷碼寄存器

用於格雷碼計數器樣式#2的SystemVerilog代碼包含一個二進制計數器，以消除灰度到二進制轉換的需要，並使用下一個二進制計數值進行二進制到灰度轉換，然後將其寄存到格雷碼寄存器中。這種類型使用兩倍多的觸發器，但使用更短的組合邏輯路徑來生成下一個格雷碼值，這使得這種實現比格雷碼計數器類型#1更快。
    2型格雷碼計數器的框圖如圖28所示，示例5中示出了用於格雷碼計數器樣式#2的相應參數化SystemVerilog模型。

```verilog
module graycntr #(parameter SIZE = 5)
(output logic [SIZE-1:0] gray,
input logic clk, full, inc, rst_n);
logic [SIZE-1:0] gnext, bnext, bin;
always_ff @(posedge clk or negedge rst_n)
if (!wrst_n) {bin, gray} <= '0;
else {bin, gray} <= {bnext, gnext};
assign bnext = !full ? bin + inc : bin;
assign gnext = (bnext>>1) ^ bnext;
endmodule
```

### 5.8 Additional multi-bit CDC techniques（額外的多位CDC技術）

除了前面章節中描述的MCP方案技術之外，我發現許多工程師使用標準FIFO在時鐘域之間傳遞數據和控制信號。至少有兩種有趣的FIFO實現策略可用於解決多位CDC信號完整性問題：
（1） 異步FIFO實現。
（2） 2-deepFIFO實現。

### 5.8.1 Multi-bit CDC signal passing using asynchronous FIFOS（使用異步FIFOS傳遞多位CDC信號）

傳遞多個比特，無論是數據比特還是控制比特，都可以通過異步FIFO來完成。異步FIFO是一種共享存儲器或寄存器緩衝區，其中數據從寫入時鐘域插入，數據從讀取時鐘域移除。由於發送器和接收器都在各自的時鐘域內工作，因此使用雙端口緩衝器（如FIFO）是在時鐘域之間傳遞多位值的安全方式。

    只要FIFO未滿，標準異步FIFO設備就允許插入多個數據或控制字，並且只要FIFO未空，接收器就可以在方便時提取多個數據和控制字。

    FIFO設計中的大部分艱苦工作都是通過格雷碼計數器的同步來完成的，[1]中描述了一種行之有效的FIFO設計技術。

### 5.8.2 Multi-bit CDC signal passing using 1-deep / 2-register FIFO synchronizer（使用1-deep/2寄存器FIFO同步器傳遞多位CDC信號）

跨CDC邊界傳遞多個控制和數據位的另一個有趣的變化涉及使用一個1-deep兩寄存器FIFO，如圖29所示。

![                                                                                         圖29-1-deep/2寄存器FIFO同步器框圖](attachment:c5c051f2-ccb9-44fe-b0d9-ed5510aa405d:39501fed31f42e5ca641dfb6484f340a.png)

                                                                                         圖29-1-deep/2寄存器FIFO同步器框圖

    這種一級雙寄存器FIFO具有許多有趣的特性。由於FIFO只使用兩個寄存器或一個2深雙端口RAM構建，用於檢測滿和空的格雷碼計數器是簡單的觸發器，實際上只不過是1位二進制計數器（請記住，標準格雷碼的最高有效位與二進制碼的最高最高有效位相同）。

    復位時，兩個指針都被清除，FIFO為空，因此FIFO未滿。我們使用反相未滿條件來指示FIFO已準備好接收數據或控制字（wrdy為高）。在數據或控制字被放入FIFO（使用wput）後，wptr翻轉，FIFO變滿，或者換句話說，wrdy信號變低，這也禁用了翻轉wptr的能力，因此也禁用了將另一個字放入2寄存器FIFO的能力，直到接收時鐘域邏輯從FIFO中移除第一個字。

    這種設計特別有趣的是，wptr現在指向2寄存器FIFO中的第二個位置，因此當FIFO再次準備就緒時（當wrdy為高時），wptr已經指向下一個要寫入的位置。

    在FIFO的接收端複製了相同的概念。當數據或控制字被寫入FIFO時，FIFO不會變為空。我們使用反相非空條件來指示FIFO具有準備好接收的數據或控制字（rrdy為高）。

    通過使用兩個寄存器來存儲多位CDC值，我們能夠從發送MCP方案中去除一個時鐘週期，從確認反饋路徑中去除另一個週期。