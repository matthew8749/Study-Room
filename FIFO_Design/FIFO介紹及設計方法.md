# FIFO介紹及設計方法

## 1. FIFO (First Input First Output) 架構
在數位電路中，FIFO(First In, First Out)是一種資料緩衝區(buffer)，用來暫存資料並確保輸入資料的順序在輸出時保持不變，此記憶體的資料先進先出(後進後出)。
根據FIFO工作的時脈域分為兩種:

- **同步FIFO:** 指<ins>讀時脈</ins>和<ins>寫入時脈</ins>為同一個時脈在時脈沿來臨時同時發生讀寫。
同步FIFO之所以稱為“同步”，是因為它採用同步時脈來控制讀寫操作。
FIFO的讀寫指標與時脈同步更新，資料與時脈同步在FIFO與外部電路之間傳輸。
主要用於在資料傳輸速率超過資料處理速率時緩衝資料。這在高速系統中特別重要，因為時間差異可能導致資料遺失或損壞。
- **非同步FIFO:** 讀寫時脈不一致，讀寫相互獨立。所以存在跨時脈域的處理。

- 一個硬體 FIFO 通常包括以下部分：
  - 儲存陣列（Memory Array）&ensp;&ensp;&ensp;&ensp;&nbsp;：暫存資料。
  - 寫指標（Write Pointer）&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&nbsp;：指出下一筆資料要寫入的位置。
  - 讀指標（Read Pointer）&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&nbsp;：指出下一筆資料要讀出的資料位置。
  - 空/滿 訊號（Empty / Full Flags）：判斷 FIFO 是否已滿或已空。

- 儲存陣列通常使用 RAM (Random Access Memory) 實現。 根據 FIFO 的深度和寬度，RAM 可以是單端口 (single-port) 或雙端口 (dual-port)。 雙端口 RAM 允許同時進行讀寫操作，可以提高 FIFO 的性能。
- RAM 的選擇會影響 FIFO 的性能和複雜度。

<!-- 這句看不見，一句話的註解 -->  
<!--
| 注意部分                         	| 作用                             	|
|----------------------------------	|----------------------------------	|
| 儲存陣列（Memory Array）          | 暫存資料。                       	|
| 寫指標（Write Pointer）          	| 指出下一筆資料要寫入的位置。     	|
| 讀指標（Read Pointer）           	| 指出下一筆資料要讀出的資料位置。 	|
| 空/滿 訊號（Empty / Full Flags） 	| 判斷 FIFO 是否已滿或已空。       	|
 -->  


## 2. 同步FIFO(Synchronous FIFO)設計

- 重要參數  
`深度`、`寬度`、`空白標誌`、`滿標誌`、`讀取時鐘`、`讀時針`、`寫入時鐘`和`寫入時針`

- 深度和寬度  
`位寬 WIDTH`：表示FIFO裡面每個資料的大小  
`深度 DEPTH`：表示FIFO能存多少個數據

- 讀取時鐘 and 寫入時鐘  
在同步FIFO中這兩個是相同的
clk dege來時，會讀取和寫入data


- 讀時針(rd_ptr) and 寫入時針(wr_ptr)  
  - 指向下一個即將要讀取或寫入的位置。讀寫操作的執行前提是讀寫使能信號 (rd_en, wr_en) 有效，並且 FIFO 沒有滿 (對於寫入) 或空 (對於讀取)。 在每次成功的讀寫操作 之後，相應的指針會 遞增，指向下一個可用的位置。  
  - 它們是用來指示RAM位址的索引，透過指標值的比較可以判斷FIFO的空滿狀態。

- 滿/空標誌邏輯:  
    - **滿:** 當寫入指針追上讀取指針時，FIFO 為滿。 更精確地說，如果下一次寫入將使 wr_ptr 等於 rd_ptr，並且當前正在執行寫入操作，則 FIFO 為滿。  

    - **空:** 當讀取指針追上寫入指針時，FIFO 為空。 更精確地說，如果下一次讀取將使 rd_ptr 等於 wr_ptr，並且當前正在執行讀取操作，則 FIFO 為空。

    - **初始狀態:** 當 wr_ptr 等於 rd_ptr 時，FIFO 初始狀態為空。  
    > 注意: 要考慮到重頭開始的狀況  
    > 意思是指 **繞回 (Wrap-around)** 的考慮: 當指針繞回時，簡單的比較 wr_ptr == rd_ptr 無法區分滿和空。 因此，通常使用額外的一位 (extra bit) 來擴展指針，以區分這些情況。   


- 定義電路介面
  ``` verilog
  module sync_fifo
  #(
    parameter                       ADR_BIT =  6,
    parameter                       DAT_BIT = 32,
    parameter                       WEN_BIT =  1
  )(
    input  logic                    clk,
    input  logic                    rst_n,

    //當 cs_en 為高且 wr_en 為高時，表示一個寫入請求。
    //當 cs_en 為高且 wr_en 為低時，表示一個讀取請求。
    //當 cs_en 為低時，表示沒有任何操作請求。
    input  logic [WEN_BIT-1: 0]     cs_en,          // higi activ  
    input  logic [WEN_BIT-1: 0]     wr_en,          // higi activ
    input  logic [DAT_BIT-1: 0]     wr_dat,


    output logic [DAT_BIT-1: 0]     rd_dat,
    output logic                    fifo_full,
    output logic                    fifo_empty,
    output logic [ADR_BIT : 0]      fifo_count      // for testbench display
  );
  ```

### 2.1 同步FIFO完整程式碼
<details>
  <summary>sync_fifo.sv</summary>

```verilog
// +FHDR--------------------------------------------------------------------------------------------------------- //
// Project ____________                                                                                           //
// File name __________ sync_fifo.sv                                                                              //
// Creator ____________ Yan, Wei-Ting                                                                             //
// Built Date _________ MMM-DD-YYYY                                                                               //
// Function ___________                                                                                           //
// Hierarchy __________                                                                                           //
//   Parent ___________                                                                                           //
//   Children _________                                                                                           //
// Revision history ___ Date        Author            Description                                                 //
//                  ___                                                                                           //
// -FHDR--------------------------------------------------------------------------------------------------------- //
//+...........+...................+.............................................................................. //
//3...........15..................35............................................................................. //
`timescale 1ns/10ps

module sync_fifo
#(
  parameter                       ADR_BIT =  6,
  parameter                       DAT_BIT = 32,
  parameter                       WEN_BIT =  1
)(
  input  logic                    clk,
  input  logic                    rst_n,

  input  logic [WEN_BIT-1: 0]     cs_en,          // higi activ
  input  logic [WEN_BIT-1: 0]     wr_en,          // higi activ
  input  logic [DAT_BIT-1: 0]     wr_dat,


  output logic [DAT_BIT-1: 0]     rd_dat,
  output logic                    fifo_full,
  output logic                    fifo_empty,
  output logic [ADR_BIT : 0]      fifo_count      // for testbench display
);

// tag COMPONENTs and SIGNALs declaration --------------------------------------------------------------------------

  //
  logic    [ADR_BIT     : 0]      wr_ptr;
  logic    [ADR_BIT     : 0]      rd_ptr;

  // RAM 控制信號
  logic    [WEN_BIT-1   : 0]      ram_cen;
  logic    [WEN_BIT-1   : 0]      ram_wen;
  logic    [ADR_BIT-1   : 0]      ram_addr;
  logic    [DAT_BIT-1   : 0]      ram_wdata;
  logic    [DAT_BIT-1   : 0]      ram_rdata;

  // base on cs_en & wr_en
  logic                           rd_req;
  logic                           wr_req;
  logic                           wr_actual;
  logic                           rd_actual;

// tag OUTs assignment ---------------------------------------------------------------------------------------------
assign rd_dat      = ram_rdata;

// tag INs assignment ----------------------------------------------------------------------------------------------


// tag COMBINATIONAL LOGIC -----------------------------------------------------------------------------------------

//當 cs_en 為高且 wr_en 為高時，表示一個寫入請求。
//當 cs_en 為高且 wr_en 為低時，表示一個讀取請求。
//當 cs_en 為低時，表示沒有任何操作請求。
assign        rd_req              = (cs_en == 1'b1 && wr_en == 1'b0 );
assign        wr_req              = (cs_en == 1'b1 && wr_en == 1'b1 );

assign        wr_actual           = wr_req && !fifo_full;
assign        rd_actual           = !wr_actual && rd_req && !fifo_empty;

assign fifo_full   = ( wr_ptr[ADR_BIT] != rd_ptr[ADR_BIT]) && ( wr_ptr[ADR_BIT-1 : 0] == rd_ptr[ADR_BIT-1 : 0] );
assign fifo_empty  = ( wr_ptr == rd_ptr);
assign fifo_count  = wr_ptr - rd_ptr;                 // for testbench display

// tag COMBINATIONAL PROCESS ---------------------------------------------------------------------------------------
always_comb begin
  ram_cen                         = {WEN_BIT{1'b1}};
  ram_wen                         = {WEN_BIT{1'b1}};
  ram_addr                        = 'd0;
  ram_wdata                       = 'd0;

  if ( wr_actual ) begin
  ram_cen                         = {WEN_BIT{1'b0}};
  ram_wen                         = {WEN_BIT{1'b0}};
  ram_addr                        = wr_ptr[ADR_BIT-1:0];
  ram_wdata                       = wr_dat;
  end else if ( rd_actual ) begin
  ram_cen                         = {WEN_BIT{1'b0}};
  ram_wen                         = {WEN_BIT{1'b1}};
  ram_addr                        = rd_ptr[ADR_BIT-1:0];
  end

end

// tag SEQUENTIAL LOGIC --------------------------------------------------------------------------------------------
// ***********************/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**
//                       /**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/***
// *********************/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/****

 sim_ram_top #(
  .ADR_BIT ( ADR_BIT       ),
  .DAT_BIT ( DAT_BIT       ),
  .WEN_BIT ( WEN_BIT       )
) u_ram (
  .clk     ( clk       ),
  .rst_n   ( rst_n     ),
  .CEN     ( ram_cen   ),  //low activ
  .WEN     ( ram_wen   ),  //low activ
  .addr    ( ram_addr  ),
  .w_data  ( ram_wdata ),
  .r_data  ( ram_rdata )
);

// ***********************/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**
// 讀寫指針更新            /**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/***
// *********************/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/****
always_ff @ ( posedge clk or negedge rst_n) begin
  if ( !rst_n ) begin
    wr_ptr <= {ADR_BIT{1'b0}};
  end else begin
    if ( wr_actual ) begin
      wr_ptr <= wr_ptr + 1'b1;
    end else begin
      wr_ptr <= wr_ptr;
    end


  end
end

always_ff @ ( posedge clk or negedge rst_n) begin
  if ( !rst_n ) begin
    rd_ptr <= {ADR_BIT{1'b0}};
  end else begin
    if ( rd_actual ) begin
      rd_ptr <= rd_ptr + 1'b1;
    end else begin
      rd_ptr <= rd_ptr;
    end


  end
end
// ***********************/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**
//                       /**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/***
// *********************/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/****


endmodule
```
</details>


### 2.2 同步FIFO testbench程式碼

<details>
<summary>sim_sync_fifo.sv</summary>

```verilog
// +FHDR--------------------------------------------------------------------------------------------------------- //
// Project ____________                                                                                           //
// File name __________ sim_sync_fifo.v                                                                              //
// Creator ____________ Yan, Wei-Ting                                                                             //
// Built Date _________ MMM-DD-YYYY                                                                               //
// Function ___________                                                                                           //
// Hierarchy __________                                                                                           //
//   Parent ___________                                                                                           //
//   Children _________                                                                                           //
// Revision history ___ Date        Author            Description                                                 //
//                  ___                                                                                           //
// -FHDR--------------------------------------------------------------------------------------------------------- //
//+...........+...................+.............................................................................. //
//3...........15..................35............................................................................. //
//`timescale 1ns/10ps

// test pattern
//1. 寫入測試：連續寫入數據直到 FIFO 滿
//2. 讀取測試：連續讀取直到 FIFO 空
//3. 讀寫交替測試


module sim_sync_fifo;

// tag COMPONENTs and SIGNALs declaration --------------------------------------------------------------------------
  //localparam STIM = "./vectors/stim_zero.txt";
  parameter                       ADR_BIT =  6;
  parameter                       DAT_BIT = 32;
  parameter                       WEN_BIT =  1;

  logic                           ref_clk_i;
  logic                           slow_clk_i;
  logic                           test_clk_i;
  logic                           rstn_glob_i;

// tag OUTs assignment ---------------------------------------------------------------------------------------------
// tag INs assignment ----------------------------------------------------------------------------------------------
// tag COMBINATIONAL LOGIC -----------------------------------------------------------------------------------------
// tag COMBINATIONAL PROCESS ---------------------------------------------------------------------------------------
// tag SEQUENTIAL LOGIC --------------------------------------------------------------------------------------------
// ***********************/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**
//                       /**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/***
// *********************/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/****
// clock gen
tb_clk_gen #(
    //.CLK_PERIOD(REF_CLK_PERIOD)
    .CLK_PERIOD(3.33)   // 5 --> 200MHz
  ) i_ref_clk_gen (
    .clk_o(ref_clk_i)
  );
// ***********************/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**
//                       /**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/***
// *********************/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/****

  //fufo input
  logic       [WEN_BIT-1   : 0]   cs_en;
  logic       [WEN_BIT-1   : 0]   wr_en;
  logic       [DAT_BIT-1   : 0]   wr_dat;
  logic       [DAT_BIT-1   : 0]   rd_dat;

  //fifo optput
  logic                           fifo_full;
  logic                           fifo_empty;
  logic       [ADR_BIT : 0]       fifo_count;

sync_fifo #(
  .ADR_BIT    (   ADR_BIT         ),
  .DAT_BIT    (   DAT_BIT         ),
  .WEN_BIT    (   WEN_BIT         )
) i_sync_fifo (
  .clk        (   ref_clk_i       ),
  .rst_n      (   rstn_glob_i     ),
  .cs_en      (   cs_en           ), // high activ
  .wr_en      (   wr_en           ), // high activ
  .wr_dat     (   wr_dat          ),
  .rd_dat     (   rd_dat          ),
  .fifo_full  (   fifo_full       ),
  .fifo_empty (   fifo_empty      ),
  .fifo_count (   fifo_count      )
);

// ***********************/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**\**\****/**/**
//                       /**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/****\**\**/**/***
// *********************/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/******\**\/**/****
initial begin
    $fsdbDumpfile("./sim_sync_fifo.fsdb");
    $fsdbDumpvars(0, sim_sync_fifo, "+all");
    $fsdbDumpMDA;
  end

initial begin
  rstn_glob_i   = 1'b0;
  #15
  rstn_glob_i   = 1'b1;
end


// test pattern
//1. 寫入測試：連續寫入數據直到 FIFO 滿
//2. 讀取測試：連續讀取直到 FIFO 空
//3. 讀寫交替測試

initial begin
  cs_en        = 1'b0;
  wr_en        = 1'b0;
  wr_dat       = 'd0;
  #20


  for (int i = 0; i <66 ; i++)begin
    @(posedge ref_clk_i);
    if ( ~fifo_full ) begin
      cs_en  = 1'b1;
      wr_en  = 1'b1;
      wr_dat = i;
      $display("Time=%0t, -----  FIFO Not Full at %0d", $time, wr_dat);
    end else begin
      wr_en  = 1'b0;
      wr_dat = 0;
      $display("Time=%0t, -----  FIFO full at %0d", $time, wr_dat);
      break;
    end
  end


  wr_en  = 1'b0;
  for (int i = 0; i <66 ; i++)begin
    @(posedge ref_clk_i);
    if ( ~fifo_empty ) begin
      cs_en  = 1'b1;
      //@(posedge ref_clk_i);
      $display("Time=%0t, -----  Read data: %0d", $time, rd_dat);
    end else begin
      $display("Time=%0t, -----  Read data: %0d", $time, rd_dat);
      $display("Time=%0t, -----  FIFO empty at %0d", $time, i);
      break;
    end
  end

  #30
  $finish;

end


  // 監控 FIFO 狀態
  initial begin
    forever begin
      @(posedge ref_clk_i);
      $display("Time=%0t, Full=%0d, Empty=%0d, Count=%0d",
               $time, fifo_full, fifo_empty, fifo_count);
    end
  end

endmodule
```
</details>


### 2.3 Q&A
**🧠 問題：**  
同步 FIFO 中，在同一個時鐘邊緣，如果：
寫入資料到地址 A（write pointer 指向 A），同時讀出資料（read pointer 也指向 A）
那麼，讀出來的資料是什麼？是「原本存在 A 的值」，還是「剛寫進 A 的新值」？

**📌 答案：**  
視 FIFO 記憶體的寫入／讀出時序行為而定！
也就是說：這取決於底層 memory 的行為（通常是 RTL 中的 RAM module 的行為）。

**📚 常見兩種情況：**
1️⃣ 寫在前，讀到新資料（Write-first behavior）
- 寫入與讀出同一地址，在同一個時鐘邊緣。
- 結果：讀出剛寫進去的新資料。

📌 適合有些同步 FIFO 的需求，尤其是 latency 敏感的應用。

2️⃣ 讀在前，讀到舊資料（Read-first behavior）
- 同樣寫入與讀出同一地址。
- 結果：讀出的是原本存在的舊資料（還沒寫進去的）。

📌 在某些記憶體 IP 或是合成工具中的 RAM，預設是這種行為。

**✅ 設計建議：**
為了避免這種模糊狀況，通常會強制在 write 和 read 指標不同時才允許操作，或是加一層保護邏輯，例如：
- 只有當 FIFO 中有資料才允許讀（避免空讀）。
- 只有當 FIFO 還沒滿才允許寫（避免覆蓋）。

若要支援同步寫讀同地址，記憶體模組必須設計成 write-first 或 read-first，並在文件中說明。


## 3. 異步FIFO(Asynchronous FIFO)設計  
異步FIFO（或稱非同步FIFO, Asynchronous FIFO）是數位設計中處理 **<font color=#FFF000>跨時脈域（Clock Domain Crossing, CDC）</font>** 資料傳輸問題的關鍵。其讀寫操作分別由<font color=#FFF000>兩個獨立的時脈驅動（wr_clk 與 rd_clk）</font>，這兩個時脈在頻率或相位上可能完全不相關。非同步 FIFO 用於在這些非同步時脈域之間安全地傳輸資料。  

### 3.1 Why use Async-FIFO?  
當系統中的兩個模組需要交換資料，但它們的工作時脈不同時，就需要一個可靠的機制來銜接。若直接傳輸，會導致 **<font color=#FFF000>亞穩態 (Metastability)</font>** 問題，造成資料取樣錯誤，最終使系統崩潰。  
這時就可以用非同步FIFO解決此問題，它扮演了以下幾個重要的角色：  
- **安全的資料橋樑：** 在兩個獨立的時脈域之間，提供一個安全的資料緩衝區。  
- **速率匹配器：** 當寫入端的資料速率（由 `wr_clk` 決定）與讀取端的處理速率（由 `rd_clk` 決定）不匹配時，FIFO可以暫存資料，防止資料遺失（寫入快於讀取）或空等（讀取快於寫入）。  

對於非同步FIFO來說，讀寫分別在不同clk domain，此時最核心的問題就是 **<font color=#FFF000>空/滿的判斷</font>**

### 3.2 實作的非同步 FIFO 設計包含以下關鍵策略  
- ### 讀取與寫入操作：  
  
  ## 異步FIFO讀寫指標同步策略詳解   
  
  ### 問題背景    

  異步FIFO的讀、寫指標分別工作在不同的時鐘域，無法直接進行比較，必須先將其同步到同一個時鐘域。關鍵問題是：**指標應該同步到哪個時鐘域？**  

  可選方案包括：第三方時鐘域、讀時鐘域和寫時鐘域。讓我們逐一分析各種方案的優劣。  

  ### 同步機制說明  

  本文討論的同步方式是使用2個（或3個，但較少見）正反器（FF）進行同步，俗稱「打兩拍」。這種同步方式會產生延遲（時序開銷），大約相當於兩個目標時鐘週期。  

  ### 方案分析  
 
  #### 方案一：同步到第三方時鐘域 ❌  

  **分析過程：**  

  當信號從一個時鐘域同步到另一個時鐘域時，需要消耗一定時間（這裡僅考慮從慢到快的情況，暫不考慮漏採問題）。所需時間取決於目標時鐘域的週期以及需要同步的信號數量。  

  **問題說明：**  

  假設同步耗時為T，經過T時間後，由於讀寫時鐘頻率不同，原始的讀寫指標增量也不相同。  

  舉例：實際上讀寫指標都指向位置4（且最高位相同），此時應該出現讀空狀態。但同步到第三方時鐘域後，可能寫指標變成6，讀指標變成8（因為讀時鐘比寫時鐘快）。在這種情況下，FIFO不會報告「讀空」，造成功能異常。  

  **結論：此方案不可行。**  

  #### 方案二：讀指標同步到寫時鐘域 ✅（適用於寫滿判斷）  

  **工作原理：**  

  讀指標同步到寫時鐘域需要時間T。在T時間內，原始讀指標可能增加或保持不變，因此同步後的讀指標必定小於或等於原始讀指標。寫指標本身就在寫時鐘域，無需同步，所以比較時使用的是真實的寫指標值。  

  **寫滿判斷：**  

  判斷條件是寫指標超過同步後的讀指標一圈。由於原始讀指標 ≥ 同步後的讀指標，實際上寫指標並未超過真實讀指標一圈，這種情況稱為「假寫滿」。  
 
  **「假寫滿」是否為設計錯誤？**  

  答案是**否**。異步FIFO設計的關鍵在於產生「適當」的寫滿和讀空信號。何謂適當？應該報告時沒有報告當然不適當；不該報告時提前報告是否適當？答案是**適當的**。  

  想像一個深度為100的FIFO，在寫入第98個資料時就報告「寫滿」，會有什麼後果？答案是不會造成功能錯誤，只會造成2%的效能損失，相當於FIFO深度略微減少使用。這實際上是一種保守的安全設計。  

  **讀空判斷：**  

  判斷條件是同步後的讀指標追上寫指標。但由於原始讀指標 ≥ 同步後的讀指標，實際上讀指標已經超過寫指標，意味著已經發生讀空，卻仍有錯誤資料被讀出。**這會造成FIFO功能錯誤。**  

  #### 方案三：寫指標同步到讀時鐘域 ✅（適用於讀空判斷）  

  **工作原理：**  

  寫指標同步到讀時鐘域需要時間T。在T時間內，原始寫指標可能增加或保持不變，因此同步後的寫指標必定小於或等於原始寫指標。讀指標本身就在讀時鐘域，無需同步，所以比較時使用的是真實的讀指標值。  

  **寫滿判斷：**  

  判斷條件是同步後的寫指標超過讀指標一圈。但由於原始寫指標 ≥ 同步後的寫指標，實際上寫指標已經超過讀指標不止一圈，意味著已經發生寫滿，資料卻仍被覆蓋寫入。**這會造成FIFO功能錯誤。**  

  **讀空判斷：**  

  判斷條件是讀指標追上同步後的寫指標。但由於原始寫指標 ≥ 同步後的寫指標，實際上讀指標還未追上真實寫指標，這種情況稱為「假讀空」。  

  **「假讀空」是否為設計錯誤？**  

  答案是**否**。理由與「假寫滿」相同。想像某個FIFO在讀取到還剩2個資料時就報告「讀空」，會有什麼後果？答案是不會造成功能錯誤，只會造成輕微的效能損失，暫停讀取等待更多資料即可。這同樣是一種保守的安全設計。  

  ### 設計結論  

  基於上述分析，異步FIFO的正確設計策略如下：   

  #### ✅ 寫滿判斷  
  **將讀指標同步到寫時鐘域，再與寫指標進行比較**  
  - 允許「假寫滿」的出現  
  - 確保資料不會被意外覆蓋  
  - 輕微效能損失換取功能安全  

  #### ✅ 讀空判斷  
  **將寫指標同步到讀時鐘域，再與讀指標進行比較**  
  - 允許「假讀空」的出現  
  - 確保不會讀取到無效資料  
  - 輕微效能損失換取功能安全  

  ### 設計哲學  

  異步FIFO設計遵循「寧可保守，不可冒進」的原則。功能正確性永遠優於效能最佳化，用微小的效能犧牲換取絕對的資料安全性，這是工程實務中的最佳選擇。    

- ### 滿、空及迴繞條件：  

- ### 格雷碼計數器 (Gray code counter)：  
非同步FIFO為什麼要使用格雷碼？
非同步FIFO設計最關鍵的點是什麼？答案是「空」和「滿」的判斷。現在回想一下，我們是如何進行狀態判斷的。很簡單，分別建構讀指針和寫指針。寫指標總是指向下一個要寫的位址，而讀指標永遠指向目前要讀取的位址。再透過對讀、寫指針的比較來判斷空、滿。



<details>  
<summary> 讀取指標、寫指標應該被同步到哪個時脈域？ </summary>  

異步FIFO的讀、寫指標是不同時鐘域的信號，那麼就不能直接對比，而是需要將其同步到同一時鐘域才能進行對比。 現在問題來了？ 指標應該被同步到哪個時鐘域？ 可選項有第三方時鐘域、讀時鐘域和寫時鐘域。 接下來不妨逐個分析。  

首先需要說明的是，這說的同步都是指使用2個（或者3個，但此類情況不多）FF（觸發器）來進行同步（俗稱“打兩拍”），這種同步方式是有延遲的（時序開銷，可以看做是兩個目同步時鐘週期）。  

- **第三方時鐘域：** 不難知道一個信號從一個時鐘域同步到另一個時鐘域（被同步時鐘域）是需要時間的（這裡僅考慮從滿到快，也就是暫時不考慮漏採的問題），需要的時間取決於被同步時鐘域的週期以及需要同步的個數。   

假設這個時間是T，那麼經過T時間后，由於讀寫時鐘不一致，原來的讀寫時針增加（也可能不變）的量是不一致。 比如說實際上讀寫時針都指向4（且最高位相同），那麼這種情況實際上是出現了讀空的情況。 但是同步到第三方時鐘域后，可能寫指標成了6，而讀指標變成了8（讀時鐘比寫時鐘快），那麼在這種情況下FIFO就不會報“讀空”，從而造成功能錯亂。 所以該種方法不可取。  

- **同步到寫時鐘域：** 讀指標同步到寫時鐘域需要時間T，在經過T時間后，可能原來的讀指標會增加或者不變，也就是說同步后的讀指標一定是小於等於原來的讀指標的。 寫指標也可能發生變化，但是寫指標本來就在這個時鐘域，所以是不需要同步的，也就意味著進行對比的寫指標就是真實的寫指標。   
  - 現在來進行寫滿的判斷：也就是寫指標超過了同步后的讀指標一圈。 但是原來的讀指標是大於等於同步後的讀指標的，所以實際上這個時候寫指標其實是沒有超過讀指標一圈的，也就是說這種情況是“假寫滿”。 那麼「假寫滿」是一種錯誤的設計嗎？ 答案是NO。 前面我們說過異步FIFO設計的關鍵點是產生合適的「寫滿」和「讀空」信號，那麼何謂「合適」？ 該報的時候沒報算合適嗎？ 當然不算合適。 不該報的時候報了算不算合適？ 答案是算。 可以想像一下，假設一個深度為100的FIFO，在寫到第98個數據的時候就報了「寫滿」，會引起什麼後果？ 答案是不會造成功能錯誤，只會造成性能損失（2%），大不了FIFO的深度我少用一點點就是的。 事實上這還可以算是某種程度上的保守設計（安全）。
  - 接著進行讀空的判斷：也就是同步后的讀指標追上了寫指標。 但是原來的讀指標是大於等於同步后的讀指標的，所以實際上這個時候讀指標實際上是超過了寫指標。 這種情況意味著已經發生了“讀空”，卻仍然有錯誤數據讀出。 所以這種情況就造成了FIFO的功能錯誤。

- **同步到讀時鐘域：** 寫指標同步到讀時鐘域需要時間T，在經過T時間后，可能原來的讀指標會增加或者不變，也就是說同步后的寫指標一定是小於等於原來的寫指標的。 讀指標也可能發生變化，但是讀指標本來就在這個時鐘域，所以是不需要同步的，也就意味著進行對比的讀指標就是真實的讀指標。
  - 現在來進行寫滿的判斷：也就是同步后的寫指標超過了讀指標一圈。 但是原來的寫指標是大於等於同步後的寫指標的，所以實際上這個時候寫指標已經超過了讀指標不止一圈，這種情況意味著已經發生了“寫滿”，卻仍然數據被覆蓋寫入。 所以這種情況就造成了FIFO的功能錯誤。
  - 接著進行讀空的判斷：也就是讀指標追上了同步后的指標。 但是原來的寫指標是大於等於同步后的寫指標的，所以實際上這個時候讀指標其實還沒有追上寫指標，也就是說這種情況是“假讀空”。 那麼「假讀空」是一種錯誤的設計嗎？ 答案是NO。 前面我們說過異步FIFO設計的關鍵點是產生合適的「寫滿」和「讀空」信號，那麼何謂「合適」？ 該報的時候沒報算合適嗎？ 當然不算合適。 不該報的時候報了算不算合適？ 答案是算。 可以想像一下，假設某個FIFO，在讀到還剩2個數據的時候就報了「讀空」，會引起什麼後果？ 答案是不會造成功能錯誤，只會造成性能損失（2%），大不了我先不讀了，等數據多了再讀就是的。 事實上這還可以算是某種程度上的保守設計（安全）。
現在可以總結一下：
• 「寫滿」的判斷：需要將讀指標同步到寫時鐘域，再與寫指標判斷
• 讀空的判斷：需要將寫指標同步到讀時鐘域，再與讀指標判斷
</details>  

這篇文章深入探討了 **非同步 FIFO（First-In, First-Out）** 的設計與其七個關鍵要點：  

- **格雷碼 (Gray Code) 的應用：** 文章首先解釋了格雷碼的原理，即相鄰數字之間只有一個位元不同。這對於非同步 FIFO 設計至關重要，因為它能避免在跨時鐘域傳輸多位元信號時產生亞穩態 (Metastability) 問題。  

- **「空」與「滿」的判斷：** 設計非同步 FIFO 的核心在於精確判斷其「空」與「滿」的狀態。這需要將讀寫指針同步到適當的時鐘域：  
  - 將讀指針同步到寫時鐘域來判斷「滿」。  
  - 將寫指針同步到讀時鐘域來判斷「空」。  

- **「假滿」與「假空」：** 由於跨時鐘域同步的延遲，非同步 FIFO 的「滿」和「空」判斷信號通常不是絕對精確的，會產生「假滿」和「假空」的現象。這種「不準確性」在設計中是可以接受的，因為它是一種保守策略，旨在防止數據丟失或損壞，而非功能錯誤。  

- **非 2 次方深度 FIFO 的設計：** 文章也探討了當 FIFO 深度不是 2 的冪次方時（例如深度為 7 或 6），如何進行設計。這類 FIFO 需要特殊的格雷碼應用策略，以確保循環計數時仍然保持單比特跳變，從而維持跨時鐘域同步的可靠性。  

# Reference
1. [同步FIFO的兩種Verilog設計方法](https://blog.csdn.net/wuzhikaidetb/article/details/121136040)  
2. [面試必殺技：非同步FIFO（上） -- CDC的那些事（5）](https://zhuanlan.zhihu.com/p/148175468)






<details>
  <summary>Click me</summary>
  
  ### Heading
  1. Foo
  2. Bar
     * Baz
     * Qux

</details>